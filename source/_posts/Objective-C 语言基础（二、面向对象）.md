---
title: Objective-C 语言基础（二、面向对象）
date: 2017-04-06 23:40:18
tags:
- iOS
- Objective-C
categories:
- iOS
- Objective-C
---
## 封装
### 面向对象三大特性
- 封装性
- 继承性
- 多态性

### 什么是封装？
- 封装性就是隐藏实现细节，仅对外公开接口

### 为什么要进行封装？
- 如果没有封装，如果要访问成员变量，需要把成员变量声明为 public 的，也就是公开的，但是这样我们不能控制外界如何赋值，外界有可能赋值一些脏数据。

	```
	Student *stu = [Student new];
	// 学生年龄不能为负数
	stu->_age = -10;
	    
	```

- 可以利用封装来解决这一问题。通过封装来隐藏对象的属性和实现的细节，仅对外提供公共的访问方法。
<!-- more -->
	```
	@interface  Student : NSObject
	{
	    @public
	    int _age;
	}
	
	- (void)setAge:(int)age;
	
	@end
	
	@implementation Student
	
	- (void)setAge:(int)age
	{
	    if (age < 0)
	    {
	        NSLog(@"学生年龄不能是负数");
	        return;
	    }
	    else
	    {
	        _age = age;
	    }
	}
	
	@end
	
	int main(int argc, const char * argv[]) {
	  
	    Student *stu = [Student new];
	    // 通过封装的 set 方法给成员变量赋值
	    [stu setAge:10];
	    NSLog(@"%zd", stu->_age); // 10
	    
	    return 0;
	}

	```


- 类是数据与功能的封装，数据就是成员变量，功能就是类方法或者对象方法。
- 对数据的封装，就是对成员变量的封装。
- 不封装的缺点：当一个类把自己的成员变量暴露给外界的时候，那么该类就失去了对该成员变量的管理权，别人就可以任意的修改你的成员变量。
- 封装就是将数据隐藏起来，只能用此类的方法才可以读取或者设置数据，不可被外部任意修改是面向对象设计的本质，降低了数据被误用的可能性，提高代码的灵活性。

### 封装的好处？
- 好处
	- 将变化隔离
	- 提高安全性
- 原则
	- 将不需要对外提供的内容都隐藏起来，把属性都隐藏，提供公共的方法对其访问。

### getter 和 setter
由于经常需要定义一些方法来操作成员变量，而每个方法都必须有一个有意义的名称，而大量的起名字很麻烦，所以就有了 getter 和 setter 方法。

getter 和 setter 方法的格式和写法都是固定的，所以有了 getter 和 setter 方法，就不用去想起名字的问题。同时，getter 和 setter 方法还是程序员之间交流的一种规范，以后被人只要想到给属性赋值就立刻会想到 getter 和 setter 方法，降低了程序员之间的沟通成本。

- setter 方法
	- 作用：设置成员变量的值，可以监听属性变化。
	- 写法：
		1. setter 方法一定是对象方法
		2. setter 方法一定没有返回值
		3. 一定以 set 开头并且 set 后面跟上跟上需要设置的成员变量的名称去掉下划线，并且首字母大写。
		4. 一定有参数，参数类型一定和需要设置的成员变量的类型一致，并且参数的名称就是成员变量去掉下划线。
		
		```
		// setter 方法
		- (void)setAge:(int)age;
		
		// 实现
		- (void)setAge:(int)age
		{
			// 成员变量以下划线开头的好处，用以区分局部变量和成员变量
			_age = age;
		}
		
		```

- getter 方法
	- 作用：获取成员变量的值
	- 写法：
		1. getter 方法一定是对象方法
		2. getter 方法一定有返回值，返回值类型一定和成员变量类型一致
		3. 方法名称就是获取的成员变量名称去掉下划线。
		4. 一定没有参数。
		
		```
		// getter 方法
		- (int)age;
		
		// 实现
		- (int)age
		{
			return _age;
		}
		
		```


- 只读属性
	- 如果某一个属性只提供了 getter 方法没有提供 setter 方法，称这个属性为`只读属性`
- 只写属性
	- 如果某一个属性只提供了 setter 方法没有提供 getter 方法，称这个属性为`只写属性`
- 可读可写属性
	- 如果某一个属性既提供了 getter 方法又提供 setter 方法，称这个属性为`可读可写属性`
- 私有属性
	- 如果某一个属性既没有提供了 setter 方法也没有提供 getter 方法，称这个属性为`私有属性`

### 点语法
- 如果给属性提供了 getter 方法和 setter 方法，那么访问属性就多了一种方式，`点语法`。
- `点语法`其实本质是调用了 setter 方法和 getter 方法。
- `点语法`是一个`编译器特性`，会在程序翻译成二进制的时候，点语法自动转换为 setter 和 getter 方法。
	- 如果`点语法`在 = 号的左边，那么编译器会自动转换为 setter 方法
	
	```
	// 给 age 赋值
    stu.age = 10;
    // [stu setAge:10];
    
	```
	- 如果`点语法`在 = 号的右边，那么编译器会自动转换为 getter 方法

	```
	// 获取 age 的值
    int age = stu.age;
    // int age = [stu age]
    NSLog(@"%zd", age); // 10
    
	```

> 注意：`点语法`用于给成员变量赋值，如果不是给成员变量赋值一般情况下不建议使用，但是也可以使用。

### self 关键字
- `self` 不能离开类，离开类之后没有任何意义。
- 如果 `self` 在类方法中调用，那么 `self` 就代表调用当前类方法的那个类
- 如果 `self` 在对象方法中调用，那么 `self` 就代表调用当前对象方法的那个对象
	- 类方法中`可以`直接调用类方法
	- 类方法中`不可以`直接调用对象方法
	- 类方法中`不能`访问成员变量 

> 注意：`self` 会自动区分类方法和对象方法，如果在类方法中使用 `self` 调用对象方法，那么会直接报错。

> 不能在对象方法或者类方法中利用 `self` 调用当前 `self` 所在的方法，会死循环。
 
## 继承
### 继承基本概念
- 可以利用`继承`来解决重复代码的问题
- 只要 B 类集成了 A 类，那么 B 类就拥有 A 类所有的属性和方法
- 如所有的类都继承自 NSObject，那么所有的类都拥有 NSObject 类的所有属性和方法，如： new 方法，isa 属性。
- 继承语法：

```
@interface  Student : NSObject

```

### 继承的其他特点
- Objective-C 中的继承关系

![](http://o6heygfyq.bkt.clouddn.com/Snip20170407_1.png?imageView/0/h/220)

- 继承了某个类的类称为子类
- 被继承的类称为父类/超类
- 如果子类中有和父类中同名的方法，那么称为方法重写
- 继承的缺点
	- 提高代码的复用性
	- 可以让类与类之间产生关系，正是因为继承让类与类之间产生了关系所以才有了`多态`。
- 继承的缺点
	- 耦合性太强

>注意：继承中方法调用的顺序，如果子类自己有就先调用自己的方法，如果自己没有就调用父类的方法，如果父类也没有，就找父类的父类，一直往上找，如果找得到就调用，如果直到找到根类 NSObject，也没有找到相应的方法，那么程序就会报错。

>具体过程描述是：首先一个类实例化，那么这个这个`实例对象`和`类对象`以及这个类`所有的父类的类对象`都会在堆中分配存储空间，当指向这个实例对象的指针给该实例对象发送消息时，先在堆内存中找到这个实例对象，再通过实例对象的 isa 指针找到这个类的类对象，先从这个类的类对象中找有没有这个方法，如果有，则执行，如果没有，继续往上找这个类的父类类对象，找到就执行，找不到就一直往上，如果一直找到根类 NSObject 都没有找到这个方法，那么应用程序就会报错。

> 注意：在继承中，父类的方法（类方法和对象方法）在子类中可以重写，但是属性（成员变量）不能重写。

## 多态
父类指针可以指向子类

## 私有变量和私有方法
### 私有变量
实例变量（成员变量）既可以在 @interface 中定义，也可以在 @implementation 中定义。

写在 @implementation 中的成员变量，默认就是`私有的成员变量`，并且和利用 @private 修饰的不太一样，在 @implementation 中定义的成员变量在其他类中`无法查看`，也`无法访问`，在 @implementation 中定义的`私有变量`只能在`本类`中访问。

### 私有方法
如果只有方法的实现，没有方法的声明，那么该方法就是`私有方法`。

>注意：在 Objective-C 中，没有真正的`私有方法`，因为 Objective-C 是消息机制。是在运行时才会去找接收消息的接受者发送消息。

## property && synthesize
### 在 Xcode 4.4 以前：
#### #property 基本使用
- @property 是一个编译器指令，可以简化 getter/setter 的声明。编译器只要看到 @property，就知道要产生某一个属性的 getter/setter 声明。
- 好处是：免去手工书写 getter/setter 方法繁琐的代码。 

```
@property int age;

// 相当于
- (void)setAge:(int)age;
- (int)age;

```

#### #synthesize 基本使用
- @synthesize 是一个编译器指令，可以简化 getter/setter 的实现。编译器只要看到 @synthesize，就知道要产生某一个属性的 getter/setter 实现。
	1. 在 @synthesize 后面告诉编译器需要实现那个 @property 生成的声明
	2. 告诉 @synthesize，需要告诉将传入的值赋值给谁和返回谁的值给调用者。
	3. 如果在 @synthesize 后面没有告诉系统将传入的值赋值给谁，系统默认会赋值给和 @synthesize 后面写的名称相同的成员变量。

```
@synthesize age = _age;

// 相当于
- (void)setAge:(int)age
{
	_age = age;
}

- (int)age
{
	return _age;
}

```

### 在 Xcode 4.4 以后：
- 在 Xcode 4.4 以后，苹果对 @property 进行了一个增强，以后只要利用 @property 就可以同时生成 setter/getter 方法的声明和实现。
- 如果没有告诉 @property 要将传入的参数赋值给谁，默认 @property 会将传入的参数赋值给_开头的成员变量。
- @property 的弊端：@property 只会生成最简单的 getter/setter 方法，并不会对传入的值进行过过滤。如果想对闯入的数据进行过滤，就必须重写 getter/setter 方法。
- 如果重写了 setter 方法，那么 @property 就只会生成 getter 方法，同样，如果如果重写了 getter 方法，那么 @property 就只会生成 setter 方法。
- 如果利用 @property 来生成 setter/getter 方法，那么`可以不写`成员变量，系统会`自动`给我们生成一个_开头的成员变量。
- 如果`同时重写`了 setter/getter 方法，那么系统就`不会`生成_开头的成员变量。

>@property 自动帮我们生成的成员变量是一个私有的成员变量，也就是说是在 .m 文件中生成的，而不是在 .h 文件中生成的。 

```
@property int age;

// 相当于
- (void)setAge:(int)age;
- (int)age;

// 实现
- (void)setAge:(int)age
{
	_age = age;
}
- (int)age
{
	return _age;
}

```

#### #属性修饰符
- 格式：@property (属性修饰符) 数据类型 变量名称;
- 属性修饰符
	- readwrite：代表既生成 setter 方法，又生成 getter 方法。默认情况下，@property 的属性修饰符就是 readwrite
	- readonly：代表只生成 getter 方法，不生成 setter 方法
	- getter = getter 方法名：代表生成的 getter 方法名使用后面的名称。一般情况下，获取 BOOL 类型的属性值，都会将获取的方法名改为 isXXX
	- setter = setter 方法名：代表生成的 setter 方法名使用后面的名称

```
// 是否通过
@property (getter=isPassed) BOOL passed;

Student *stu = [Student new];
BOOL passed = stu.isPassed;

```

## 动态数据类型
### 静态类型和动态类型
#### #静态类型
- 将一个指针变量定义为特定类对象时，使用的是静态类型，在编译的时候就知道这个指针变量所属的类，这个变量总是存储特定类的对象。
- 默认情况下，所有的数据类型都是`静态数据类型`，静态数据类型特点：
	- 在编译的时候就知道变量的类型
	- 知道变量中有哪些属性和方法
	- 在编译的时候就可以访问这些属性和方法
	- 如果通过静态数据类型定义变量，如果访问了不是静态数据类型定义的属性和方法，那么编译器`将会报错`

```
Person *p = [Person new];

```

#### #动态类型
- 程序直到执行才确定对象所属的类，在编译的时候编译器并不知道变量的真实类型，只有在运行的时候才知道他的真实类型
- 如果通过`动态数据类型`定义变量，如果访问了不属于动态数据类型的属性和方法，编译器`不会报错`
- 通过动态数据类型定义的变量，可以调用子类特有的方法，而静态类型不行
- 通过动态数据类型定义的变量，还可以调用私用方法

```
id obj = [Person new];

// 1. 调用子类特有方法
[obj eat];

// 2. 调用私有方法
[obj privateMethod];

```

> 动态类型弊端：由于动态数据类型可以调用任意方法，所以有可能调用到不属于自己的方法，而编译时又不会报错，所以可能导致运行时错误

> 应用场景：多态。可以减少代码量，避免调用子类特有的方法需要强制类型转换

### 为什么要有动态类型？
- NSObject 是 Objective-C 中的基类，任何对象的 NSObject 类型的指针都可以指向任何对象，但是如果 NSObject 是静态类型，如果通过它直接调用 NSObject 上面不存在的方法，编译器会报错。
- `id` 是一个数据类型，并且是一个`动态数据类型`
- 作用
	1. 定义变量
	2. 作为函数的参数
	3. 作为函数的返回值
	
- id 是一种通用的对象类型，他可以指向属于任何类的对象，可以理解为是“万能指针”，相当于 C 语言中的 `void *`
- 因为 id 是动态数据类型，所以可以通过 id 类型直接调用指向对象中的方法，编译器不会报错
- 注意
	- 在 id 的定义中，已经包含了 * 号，id 指针只能指向 Objective-C 中的对象
	- 为了尽可能的减少编程中的错误，Xcode 做了一个检查，当使用 id 类型调用本项目中所有类上都没有的方法，编译器会报错。
	- id 类型不能使用`点语法`，因为`点语法`是编译时特性，而 id 是运行时特性。

### id 数据类型与静态类型
- 不要滥用这种通用类型
	- 如果没有使用到`多态`尽量使用静态类型
	- 静态类型可以更早的法相错误（在编译时而不是运行时）
	- 静态类型能够提高程序的可读性
	- 使用动态类型前最好知道其真实类型
- 动态类型判断
	- - (BOOL)isKindOfClass:(Class)aClass 判断实例对象是否是这个类或者这个类的子类的实例
	- 为了避免动态数据类型引发的运行时错误，一般情况下如果使用动态数据类型变量，在调用这个变量的方法之前会做一次判断，判断当前变量是否能够调用这个方法
	
	```
	id obj = [Student new];
	// 1. 判断指定对象是否是当前指定类或者他的子类
    if ([obj isKindOfClass:[Student class]])
    {
        [obj eat];
    }
    
    // 或者
    // 2. 判断指定对象是否是当前指定类的实例
    if ([obj isMemberOfClass:[Student class]])
    {
        [obj eat];
    }

	```

## new 实现原理
- new 做了三件事情
	1. 开辟存储空间，+ (instancetype)alloc 类方法
	2. 初始化所有属性（成员变量）- (instancetype)init 对象方法
	3. 返回对象的地址

```
NSObject *obj = [Student new];
// 等价于
NSObject *obj = [[Student alloc] init];

```
- alloc 类方法做了什么事情
	1. 开辟存储空间
	2. 将所有的属性设置为 0
	3. 返回当前实例对象的地址

- init 对象方法做了什么事情
	- 初始化成员变量，但是默认情况下 init 的实现是什么都没有做
	- 返回初始化后的实例对象的地址

> 注意：alloc 返回的地址和 init 返回的地址是同一个地址

## 构造方法
### 构造方法基本概念
#### #1. 重写 init 方法
- 想在对象创建完毕后，成员变量马上就有一些默认的值就可以重写 init 方法
- 重写 init 方法格式

```
- (instancetype)init
{
    self = [super init];
    if (self)
    {
        // 初始化操作
    }
    return self;
}
	
```

	  
- [super init] 的作用，面向对象的体现，先利用父类的 init 方法为子类实例的父类不分数线初始化
- self 为什么要赋值为 [super init]：简单来说是为了防止父类的初始化方法 release 掉了 self 指向的空间并重新 alloc 了一块空间，还有 [super init] 可能 alloc 失败，这时就不要再执行 if 中的语句。 


#### #2. instancetype 和 id 的区别
- 相同点：instancetype 和 id 都是万能指针，都可以指向一个对象
- 不同点：
	1. id 在编译时不能判断对象的真实类型，instancetype 在编译时可以判断对象的真实类型
	2. id 可以用来定义变量，可以作为返回值，可以当做形参，instancetype 只能当做返回值来使用

> 注意：以后凡是自定义构造方法，返回值尽量使用 instancetype，不要使用 id


### 自定义构造方法
- 其实就是自定义一个 init 方法
	1. 一定是一个对象方法
	2. 一定返回 id / instancetype
	3. 方法名称一定以 init 开头

```
Student *stu = [[Student alloc] initWithAge:25];
NSLog(@"%i", stu.age); // 25

```

- 一个类可以有 0 个或者多个自定义构造方法
- 一个自定义构造方法可以有 1 个或者多个参数

### 自定义构造方法在继承中的表现
原则：子类只负责初始化自己的成员变量，父类的成员变量初始化工作交给父类去完成

```
- (instancetype)initWithAge:(int)age name:(NSString *)name
{
	// 交给父类去初始化
    self = [super initWithAge:age];
    if (self)
    {
        _name = name;
    }
    
    return self;
}


Student *stu = [[Student alloc] initWithAge:25 name:@"chenlj"];
NSLog(@"age=%i,name=%@", stu.age,stu.name); // age=25,name=chenlj

```

### 自定义构造方法及成员变量名称注意点
1. 自定义构造方法中的 init 后面的 With 首字母必须要大写。
2. 属性名称或者方法名称不要 new 开头，有可能会引发一些未知错误。

## 类工厂方法
### 类工厂方法基本概念
- 什么是类工厂方法？
	- 用于快速创建对象的类方法，称为类工厂方法
	- 类工厂方法主要用于给对象分配存储空间以及初始化这块存储空间

- 规范
	1. 一定是类方法
	2. 方法名称以类的名称开头，首字母小写
	3. 一定有返回值，返回值是 id/instancetype

```
// 声明
+ (instancetype)personWithAge:(int)age;

// 实现
+ (instancetype)personWithAge:(int)age
{
	// 注意：在自定义类工程方法时，在类工厂方法中创建的对象一定不要使用类名来创建，一定要使用 self
	Person *p = [self alloc] init];
	// Person *p = [Person alloc] init];
	p.age = age;
	return p;
}

// 调用
Person *p = [Person personWithAge:25];

```


> 自定义类工厂方法是苹果的一个非凡，一般情况下，会给一个类提供自定义构造方法和自定义类工厂方法用于创建对象。


### 类工厂方法在继承中的注意点
- 在自定义类工程方法时，在类工厂方法中创建的对象一定不要使用类名来创建，一定要使用 self
- self 在类方法中代表类对象，谁调用这个类方法，self 就代表谁


## 类的本质及存储细节
### 类的本质
- 类的本质其实也是一个对象（类对象）
- 程序中第一次使用该类的时候被创建，在整个程序中只有一份
- 伺候每次使用都是这个类对象，他在程序运行时一直存在
- 类对象是一种数据结构，存储类的基本信息：类大小，类名称，类的版本，继承层次，以及消息与函数的映射表等
- 类对象代表类，Class 类型，对象方法属于类对象
- 如果消息的接受者是类名，则类名代表类对象
- 所有类的实例都是由`类对象`生成，类对象会把实例的 isa 指针的值修改成自己的地址，每个实例的 isa 指针都指向该实例的类对象

- 假设有一个 Person 类

```
@interface  Person : NSObject

@property int age;

// 对象方法
- (void)instanceMethod;

// 类方法
+ (void)classMethod;

@end

@implementation Person

// 对象方法
- (void)instanceMethod
{
    NSLog(@"instanceMethod");
}

// 类方法
+ (void)classMethod
{
    NSLog(@"classMethod");
}

@end

int main(int argc, const char * argv[]) {
  
    Person *p = [[Person alloc] init];
    
    // 调用对象方法
    [p instanceMethod];
    
    // 调用类方法
    [Person classMethod];

    return 0;
}

```

Person 类在内存中的表现是：

![](http://o6heygfyq.bkt.clouddn.com/class%20momory.001.jpeg?imageView/0/w/650)


#### #说明
- 程序一启动，就会将 Person 类加载到代码区，会调用类的 load 方法，当程序第一次使用 Person 类时，会在`堆`中创建 Person 类对象。类对象在程序运行时一直存在，并且在整个程序中只有一份。
- 对象方法保存在`类对象`中
- 类方法保存在`元类对象`中
- 所有`实例对象`都是通过`类对象`生成，`类对象`会把实例的 isa 指针的值修改成自己的地址。并且把类中的所有属性（成员变量）拷贝一份到实例变量。

</br>
#### #对象方法调用顺序
首先创建一个实例对象，会在堆中给实例对象分配存储空间，然后将实例对象中的所有属性初始化为 0，最后返回实例对象的地址给指针变量 p。当发生对象方法调用时，指针变量 p 会先到堆中找到相应的实例变量的存储空间，然后通过`实例变量`的 isa 指针找到对应的`类对象`，找到类对象中对象方法列表中的相应的对象方法，最后执行。

</br>
#### #类方法调用顺序
当类方法调用发生时，首先会去堆中找到相应的`类对象`，然后通过`类对象`中 isa 指针找到指向的`元类对象`，最后找元类对象中类方法列表中的相应的类方法，如果找到，执行，如果没有找到，继续向上找`根元类对象（NSObject 元类对象）`。

</br>
#### #对象模型图

![](http://o6heygfyq.bkt.clouddn.com/Snip20170407_4.png)

</br>
>所有类的“`类对象`”的继承关系就是“`元类对象`”的继承关系。这样便于方法的查找。首先`实例对象`的 isa 指针指向`类对象`，`类对象`的 isa 指针指向`元类对象`，`元类对象`的 isa 指针指向`根元类对象`，`根元类对象`的 isa 指针`指向自己`。其次在`类对象`中存储着对象方法，`元类对象`中存储着类方法。当一个子类要执行一个对象方法时，先到自己`类对象`中找，如果找到就执行，找不到就要去`类对象的父类对象`中找。同理，如果一个子类要执行一个类方法时，先到自己的元类对象中找，如果找到就执行，找不到就要去`元类对象`的`父类元类对象`中找。


### 如何获取类对象 & 类对象的应用场景
- 通过实例对象获取
	
```
格式：[实例对象 class]；
	
```
	
- 通过类名获取（类名其实就是类对象）
	
```
格式：[类对象 class];
	
```

- 类对象的应用场景
	1. 用于创建对象实例
	2. 用于调用类方法

```
// 获取类对象
// 1. 通过实例获取
Class c1 = [p class];
// 2. 通过类对象获取
Class c2 = [Person class];
NSLog(@"c1 = %p, c2 = %p", c1, c2); //  c1 = 0x100001260, c2 = 0x100001260
    
// 类对象应用场景
// 1. 用于创建实例对象
Person *p2 = [[c1 alloc] init];
p2.age = 25;
NSLog(@"%i", p2.age); // 25
// 2. 用于调用类方法
[c1 classMethod]; // classMethod
    
```

## 类的启动过程

```
// 只要程序启动就会将类的代码加载到内存中，放到代码区
// load 方法会在当前类被加载到内存的时候调用，有且仅会调用一次
// 如果存在继承关系，会先调用父类的 load 方法，再调用子类的 load 方法
+ (void)load
{
    
}

// 当前类第一次被使用时调用（创建类对象的时候）
// initialize 方法在整个程序运行过程中只会调用一次，无论使用多少次真个类都只会调用一次
// initialize 用于对某一个类进行一次性的初始化
// 如果存在继承关系，会先调用父类的 initialize 方法，再调用子类的 initialize 方法
+ (void)initialize
{
    
}

```