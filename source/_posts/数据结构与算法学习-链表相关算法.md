---
title: 数据结构与算法学习-链表相关算法
date: 2019-03-08 11:49:59
- 数据结构
- 算法
categories:
- 数据结构
- 算法
---


## 前言

上一篇文章讲了链表相关的概念，这篇主要记录的是和链表相关的算法。


## 实现单链表、循环链表、双向链表，支持增删操作

#### 1. 单链表

```C

// 头文件 ----------------------------------------------------------
typedef struct _node {
     int value; // 数据域
    struct _node *next; // 指针域
} Node;

typedef struct _list {
    Node *head; // 头指针
    Node *tail; // 尾指针
    int length; // 链表的长度
} SingleList;

// 创建链表
SingleList * creatList(void);
// 释放链表
void freeList(SingleList *pList);

// 给链表末尾添加一个结点
void appendNode(SingleList *pList, int value);
// 删除末尾结点
void removeLastNode(SingleList *pList);

// 在指定位置插入一个结点
void insertNodeAtIndex(SingleList *pList, int index, int value);
// 在指定位置删除一个结点
void deleteNodeAtIndex(SingleList *pList, int index);


// 打印链表中所有结点值
void printList(SingleList *pList);

// .m 文件 --------------------------------------------------------------------
SingleList * creatList(void)
{
    SingleList *pList = (SingleList *)malloc(sizeof(SingleList));
    pList->head = NULL;
    pList->tail = NULL;
    pList->length = 0;

    return pList;
}

// 释放链表
void freeList(SingleList *pList)
{
    if(pList == NULL) {
        return;
    }

    if (pList->head == NULL) {
        free(pList);
        return;
    }

    // 用q 来保存下一个p节点
    Node *p, *q = NULL;
    for (p = pList->head; p; p = q) {
        q = p->next;
        free(p);
    }

    free(pList);
}

// 给链表末尾添加一个结点
void appendNode(SingleList *pList, int value)
{
    // 制造一个结点，加入链表中去
    Node *p = (Node *)malloc(sizeof(Node));
    p->value = value;
    p->next = NULL;

    // 如果链表为空
    if (pList->head == NULL) {
        // p 结点就是头结点，也是尾结点
        pList->head = pList->tail = p;
    } else {
        pList->tail->next = p;
        // 更新尾指针
        pList->tail = p;
    }

    pList->length += 1;
}

// 删除末尾结点
void removeLastNode(SingleList *pList)
{
    if (pList->tail == NULL) {
        // 链表为空
        printf("链表为空!!!!");
        return;
    }

    if (pList->head == pList->tail) {
        // 链表只有一个结点
        pList->head = pList->tail = NULL;
        pList->length -= 1;

        return;
    }

    // 需要先遍历的到尾结点的上一个结点，然后删除尾结点，再更新尾结点
    Node *p = pList->head;
    while (p->next != pList->tail) {
        p = p->next;
    }

    // 释放尾结点
    free(pList->tail);
    p->next = NULL;
    pList->length -= 1;

    // 更新尾结点
    pList->tail = p;
}

// 在指定位置插入一个结点，下标从 0 开始
void insertNodeAtIndex(SingleList *pList, int index, int value)
{
    if (index >= pList->length || index < 0) {
        // 下标越界
        printf("下标不合法!!!");
        return;
    }

    // 制造一个结点，加入链表中去
    Node *s = (Node *)malloc(sizeof(Node));
    s->value = value;
    s->next = NULL;

    Node *p = pList->head;
    Node *q = NULL;

    for (int i = 0; i < pList->length; i ++) {
        // 找到了要插入的节点位置
        if (i == index) {
          if (i == 0) {
              // 插入到头结点
              s->next = pList->head;
              pList->head = s;

          } else {
              s->next = p;
              q->next = s;
          }

          pList->length += 1;
          break;
        }

        q = p;
        p = p->next;

  }

}

// 在指定位置删除一个结点
void deleteNodeAtIndex(SingleList *pList, int index)
{
    if (index >= pList->length || index < 0) {
        // 下标越界
        printf("下标不合法!!!");
        return;
    }

    Node *p = pList->head;
    Node *q = NULL;
    for (int i = 0; i < pList->length; i ++) {
        if (index == i) {
            if (i == 0) {
                // 首节点，将链表的首节点指向
                pList->head = p->next;
            } else {
                q->next = p->next;
            }

            free(p);
            pList->length -= 1;
            break;
        }

        // 用 q 来记录 p 的上一个结点
        q = p;
        p = p->next;
    }
}

// 打印链表中所有结点值
void printList(SingleList *pList)
{
    Node *p = pList->head;
    if (p == NULL) {
        printf("链表为空!!!");
    }
    while (p) {
        printf("%d\n", p->value);
        p = p->next;
    }
}

// 测试代码 ------------------------------------------------------
SingleList *pList = creatList();
// 加入结点
printf("------加入结点\n");
appendNode(pList, 10);
appendNode(pList, 20);
appendNode(pList, 30);
appendNode(pList, 40);
appendNode(pList, 50);

printList(pList);

printf("------删除结点\n");
removeLastNode(pList);
printList(pList);

printf("------插入新结点到头结点位置\n");
insertNodeAtIndex(pList, 0, 100);
printList(pList);

printf("------插入新结点到尾结点位置\n");
insertNodeAtIndex(pList, 4, 200);
printList(pList);

printf("------插入新结点到中间结点位置\n");
insertNodeAtIndex(pList, 1, 300);
printList(pList);

printf("------插入新结点到中间结点位置\n");
insertNodeAtIndex(pList, 3, 500);
printList(pList);


printf("------删除头结点\n");
deleteNodeAtIndex(pList, 0);
printList(pList);

printf("------删除尾结点\n");
deleteNodeAtIndex(pList, 6);
printList(pList);

printf("------删除中间结点\n");
deleteNodeAtIndex(pList, 3);
printList(pList);

printf("------删除中间结点\n");
deleteNodeAtIndex(pList, 2);
printList(pList);

// 释放链表
freeList(pList);

// 打印日志 ---------------------------------------------------
------加入结点
10
20
30
40
50
------删除结点
10
20
30
40
------插入新结点到头结点位置
100
10
20
30
40
------插入新结点到尾结点位置
100
10
20
30
200
40
------插入新结点到中间结点位置
100
300
10
20
30
200
40
------插入新结点到中间结点位置
100
300
10
500
20
30
200
40
------删除头结点
300
10
500
20
30
200
40
------删除尾结点
300
10
500
20
30
200
------删除中间结点
300
10
500
30
200
------删除中间结点
300
10
30
200
Program ended with exit code: 0
```

#### 2. 循环链表







#### 3. 双向链表




## 实现两个有序的链表合并为一个有序链表



## 实现求链表的中间结点



## leetcode 相关练习

#### 1. 反转一个单链表

[题目地址](https://leetcode.com/problems/reverse-linked-list/)


#### 2. 两两交换链表中的节点
[题目地址](https://leetcode.com/problems/swap-nodes-in-pairs/)


#### 3. 判断链表是否有环
[题目地址](https://leetcode.com/problems/linked-list-cycle/)

#### 4. 环形链表
[题目地址](https://leetcode.com/problems/linked-list-cycle-ii/)

#### 5. 每 k 个节点一组翻转链表
[题目地址](https://leetcode.com/problems/reverse-nodes-in-k-group/)





---
分享个人技术学习记录和跑步马拉松训练比赛、读书笔记等内容，感兴趣的朋友可以关注我的公众号「青争哥哥」。

![](http://liangjinggege.com/qrcode_for_gh_0be790c1f754_258.jpg)