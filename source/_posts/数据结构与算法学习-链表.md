---
title: 数据结构与算法学习-链表
date: 2019-03-07 15:52:20
tags:
- 数据结构
- 算法
categories:
- 数据结构
- 算法
---


## 前言

这一篇笔记主要记录总结了`线性表`数据结构中的`链表`概念，以及和`数组`的对比，最后实现了`相关的算法`。

## 链表概念

[上一篇数组]()讲了数组是一种是一种`线性表`数据结构，是用一组`连续的内存空间`，来存储一组具有`相同数据类型`的数据。和数组相同的是，`链表`也是一种`线性表`数据结构，不同的是链表是通过指针将`一组零散的内存块`串联起来存储数据，可以存储`不同数据类型`的数据。

![](http://liangjinggege.com/arrayLinkList.jpg)

链表的种类五花八门，主要有以下几类：

### 单链表

每个内存块被称为链表的`结点`，每个结点包含了`数据域`和`指针域`，数据域存储数据，指针域的指针指向`下一个结点的内存地址`，称为`后继指针next`。

另外，通常把第一个结点称作`头结点`，头结点用来记录链表的`基地址`，有了头结点就可以遍历整个链表。最后一个结点称作`尾节点`，尾结点的指针`指向NUll`。

![](http://liangjinggege.com/singleLinkList.jpg)

### 循环链表

`循环链表`是一种`特殊的单链表`。和单链表唯一的区别是循环链表的尾指针不是指向NUll，而是指向`头结点`。像环一样首尾相连，所以叫做`循环链表`。

`循环链表`的优点是在处理的数据具有环形结构特点时，特别适合使用，如经典的[约瑟夫问题](https://zh.wikipedia.org/wiki/%E7%BA%A6%E7%91%9F%E5%A4%AB%E6%96%AF%E9%97%AE%E9%A2%98)。

![](http://liangjinggege.com/loopLinkList.jpg)

### 双向链表

`双向链表`除了像单链表一样结点指针域有后继指针外，还有`前驱指针prev`，指向`上一个结点`。

缺点是需要额外开辟两个空间来存储后继结点和前驱结点的地址，如果存储同样的数据，双向链表要比单链表`占用更多的空间`。

优点是支持`双向遍历`，可以在 `O(1)的复杂度`下找到前驱结点，所以在某些情况下的插入、删除等操作比单链表简单高效。

如删除指定指针指向的结点q，单链表需要先遍历找到到这个结点的前驱结点，直到 p->nex = q， 时间复杂度是O(n)，而`双向链表`的结点指针域中已经存储了前驱结点的指针，不需要遍历，时间复杂度是O(1)。同理，要在指定结点前面插入一个结点，使用`双向链表`也是只要 O(1) 复杂度就能完成。

另外，对于有序链表，查找一个数据时，可以记录上次查找的数据的位置p，后面的查找的数据可以和 p 位置的数据比大小，决定是向前还是向后查找，这样平均查找只需要找一半的数据。

>`双向链表`里面有个重要的设计思想就是`空间换时间`思想，当需要很在意运行时间时，可以选择空间复杂度较高而时间复杂度相对较低的算法或者数据结构，相反，如果内存空间比较重要，如在单片机上的程序，就要反过来使用`时间换空间`思想。
>`缓存`的思想就是利用了空间换时间，让经常使用到的数据存储到到高速的内存中，大大提高了数据读取的速度。


![](http://liangjinggege.com/doubleLinkList.jpg)


### 双向循环链表

`双向循环链表`是`双向链表`和`循环链表`的结合体，相比较`双向链表`，尾结点的`后继指针`指向了头结点，头结点的`前驱指针`指向尾结点。

![](http://liangjinggege.com/doubleLoopLinkList.jpg)


## 链表和数组对比

可以看到，再算法时间复杂度上，数组和链表在`随机访问`和`插入删除`的复杂度上`正好相反`。

![](http://liangjinggege.com/arrayAndLinkListComplex.jpg)

数组是用一组连续的内存空间来存储数据，优点是可以借助 CPU 缓存机制，预先读取数组中的数据，访问效率更高，而链表在内存中不连续，所以对 CPU 缓存不友好。

数组的缺点是大小固定，要占用整块连续的内存空间，如果声明的数组过大，系统可能没有足够连续的空间给分配，就会导致内存不足，如果申请的数组大小过小，出现不够用，就需要重新申请一块更大的连续内存空间，然后将之前的数据全部拷贝一份过来，这个过程很耗时，而链表天然就支持`动态扩容`。

所以，如果代码对内存使用很苛刻，就使用用数组，因为链表存储相同的数据，需要更多的内存空间。在实际的开发中，需要根据不同情况选用最合适的数据结构和算法。

## 链表代码实现

```C
#include <stdio.h>
#include <stdlib.h>

// 定义链表结点
typedef struct Node {
    int Data; // 数据域
    struct Node *Next; // 指针域，指向下一个节点
}List;

// 1. 求表长
int Length(List *PtrL)
{
    List *p = PtrL; // p 指向表的第一个元素地址
    int j = 0; // 用来记录表元素的个数
    // 循环终止条件：P 为 null 了
    while (p)
    {
        p = p->Next;
        j++;
    }
    
    return j;
}

// 2. 查找(按序号查找)
List * FindKth(int K, List *PtrL)
{
    List *p = PtrL;
    int i = 1;
    while (p != NULL && i < K)
    {
        p = p->Next;
        i++;
    }
    
    if (i == K)
    {
        return p; // 找到第 K 个，返回指针
    }
    else
    {
       return NULL; // 没找到，返回 NULL
    }
}

// 2. 查找(按值查找)
List * Find(int X, List *PtrL)
{
    List *p = PtrL;
    // 循环终止条件：p = NULL，或者 p->Data = X
    while (p != NULL && p->Data != X)
    {
        p = p->Next;
    }
    
    return p;
}

// 3. 插入元素(在第 i-1(i <= i <= n +1) 个节点后插入一个值为 X 的新节点)
// 先构造一个新节点，用 s 指向
// 再找到第 i-1 个节点，用 p 指向
// 然后修改指针，插入节点（p 之后插入新节点是 s）
List * Insert(int X, int i, List *Ptrl)
{
    List *p, *s;
    // 如果插入的是表头
    if (i == 1)
    {
        s = (List *)malloc(sizeof(List));
        s->Data = X;
        s->Next = Ptrl;
        
        return s;
    }
    p = FindKth(i - 1, Ptrl);
    if (p == NULL)
    {
        printf("参数 i 错误！");
        return NULL;
    }
    else
    {
        // 把新节点插入到第 i-1 个节点的后面
        s = (List *)malloc(sizeof(List));
        s->Data = X;
        s->Next = p->Next;
        p->Next = s;
        
        return Ptrl;
    }
}

// 4. 删除元素(删除链表第 i (1 <= i <= n) 个位置的节点)
// 先找到链表第 i-1 个节点，用 p 指向
// 再用指针 s 指向要删除的节点（p 的下一各节点）
// 然后修改指针，删除 s 所指的节点
// 最后释放 s 所指节点的空间
List * Delete(int i, List *PtrL)
{
    List *p, *s;
    // 如果删除的是表头节点
    if (i == 1)
    {
        s = PtrL; // s 指向第一个节点
        if (PtrL != NULL)
        {
            PtrL = PtrL->Next; // 从链表中删除
            free(s);
            
            return PtrL;
        }
        else
        {
            return NULL;
        }
    }
    
    p = FindKth(i - 1, PtrL); // 查找第 i -1 个节点
    if (p == NULL)
    {
        printf("第%d个节点不存在", i -1);
        return NULL;
    }
    else if (p->Next == NULL)
    {
        printf("第%d个节点不存在", i);
        return NULL;
    }
    else
    {
        s = p->Next; // s 指向第 i 个节点
        p->Next = s->Next; // 从聊表中删除第 i 个节点
        free(s); // 释放被删除的节点
        
        return PtrL; // 返回新的链表
    }
}
```

## LRU 缓存淘汰算法

`最近最少使用策略 LRU` 是一种常见的`缓存策略`。常用`缓存策略`的有下列几种：
	
- 先进先出策略 FIFO(First In，Fitst Out)。
- 最少使用策略 LFU(Least Frequently Used)。
- 最近最少使用策略 LRU(Least Recently Used)。


### 链表实现

维护一个有序的单链表，越靠近链表头部的越是最近访问的，也靠近尾结点的是越早之前访问的。

1. 当该数据存在缓存的链表中，缓存命中，遍历得到数据对应到的结点，从原位置删除，然后将该结点插入到头结点位置。
2. 没有命中缓存，需要将该数据加入到缓存中，如果缓存未满，直接将该数据结点插入到链表的头部，如果缓存已满，删除链表尾结点，再将该数据结点插入到链表的头结点位置。

### 数组实现

维护一个有序的数组，下标越大越是最近访问的，下标越小越是越早之前访问的。

1. 当该数据存在数组中，缓存命中，将其



### 哈希表实现








## 课后问题

1. 如何判断一个字符串是否是回文字符串的问题，我想你应该听过，我们今天的思题目就是基于这个问题的改造版本。如果字符串是通过单链表来存储的，那该如何来判断是一个回文串呢？你有什么好的解决思路呢？相应的时间空间复杂度又是多少呢？


2. 


## 链表编程题目

### 1. 实现单链表、循环链表、双向链表，支持增删操作


### 2. 实现两个有序的链表合并为一个有序链表



### 4. 实现求链表的中间结点



## leetcode 相关练习

### 反转一个单链表

[题目地址](https://leetcode.com/problems/reverse-linked-list/)


### 两两交换链表中的节点
[题目地址](https://leetcode.com/problems/swap-nodes-in-pairs/)


### 判断链表是否有环
[题目地址](https://leetcode.com/problems/linked-list-cycle/)

### 环形链表
[题目地址](https://leetcode.com/problems/linked-list-cycle-ii/)

### 每 k 个节点一组翻转链表
[题目地址](https://leetcode.com/problems/reverse-nodes-in-k-group/)




***
分享个人技术学习记录和跑步马拉松训练比赛、读书笔记等内容，感兴趣的朋友可以关注我的公众号「马码」。

![](http://liangjinggege.com/qrcode_for_gh_0be790c1f754_258.jpg)